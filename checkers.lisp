;;;; Checkers game with AI
;;;; Copyright (C) 2014 cybevnm

(defpackage checkers
  (:use :cl
        :anaphora
        :alexandria
        :optima))
(in-package checkers)

(defun handle-slime-requests ()
  #+swank
  (let ((connection (or swank::*emacs-connection* 
                        (swank::default-connection))))
    ;;(when (and connection (not (eql swank:*communication-style* :spawn)))
    ;;  (swank::handle-requests connection t))))
    (when connection      
      (swank::handle-requests connection t))))

(defclass board ()
  ((squares :initarg :squares :reader board/squares)))
(defun board/square (board x y)
  (aref (board/squares board) x y))
(defun board/square-or-nil (board x y)
  (when (and (< -1 x (board/width board))
             (< -1 y (board/height board)))
    (board/square board x y)))
(defun (setf board/square) (val board x y)
  (setf (aref (board/squares board) x y) val))
(defun board/kill-check (board x y)
  (symbol-macrolet ((square (board/square board x y)))
    (assert (not (eq square :empty)))
    (setf square :empty)))
(defun board/opposite-check (square)
  (ecase square
    (:white-check :black-check)
    (:black-check :white-check)))
(defun board/color (x y)
  (if (xor (evenp x) (evenp y)) :white :black))
(defun $board/dimension (board axis-number)
  (array-dimension (board/squares board) axis-number))
(defun board/width (board)
  ($board/dimension board 0))
(defun board/height (board)
  ($board/dimension board 1))
(defmacro doboard ((x y square board) &body body)
  `(dotimes (,y (board/height ,board))
     (symbol-macrolet ((,square (board/square ,board x y)))
       (dotimes (,x (board/width ,board))
         ,@body))))
(defun make-board ()
  (alet (make-instance 
         'board :squares (make-array '(10 10) :initial-element :empty))
    (doboard (x y square it)
      (setf square 
            (cond
              ((and (< y 4) (eql (board/color x y) :black)) :white-check)
              ((and (> y 5) (eql (board/color x y) :black)) :black-check)
              (t :empty))))
    it))
(defparameter *squares-chars* '(:white "□" :black "■"))
(defparameter *inverted-squares-chars* '(:white "■" :black "□"))
(defun $board/square-char (color &key invert-colors)
  (getf (if invert-colors *inverted-squares-chars* *squares-chars*) color))
(defparameter *check-chars* '(:white-check "○" :black-check "●"))
(defparameter *inverted-check-chars* '(:white-check "●" :black-check "○"))
(defun $board/check-char (check &key invert-colors)
  (getf (if invert-colors *inverted-check-chars* *check-chars*) check))
(defun $board/char (board x y &key invert-colors)
  (alet (board/square board x y)
    (if (eql it :empty)
        ($board/square-char (board/color x y) :invert-colors invert-colors)
        ($board/check-char it :invert-colors invert-colors))))
(defun board/print (board &key invert-colors)
  (doboard (x y square board)
    (let ((inv-y (- (board/height board) y 1)))
      (when (zerop x) (format t "~&"))
      (format t "~A " ($board/char board x inv-y :invert-colors invert-colors)))))
(defun board/move-check (board src-x src-y tgt-x tgt-y)
  (symbol-macrolet ((src-square (board/square board src-x src-y))
                    (tgt-square (board/square board tgt-x tgt-y)))
    (assert (not (eq src-square :empty)))
    (assert (eq tgt-square :empty))
    (setf tgt-square src-square)
    (setf src-square :empty)))
(defun board/check-direction (square)
  (ecase square
    (:white-check :up)
    (:black-check :down)))

;; (defun board/square-empty-p (square)
;;   (eql square :empty))
;; (defun board/square-has-check-p (square)
;;   (not (board/emptyp square)))
;; (defmacro defmove ())

(defun square-has-same-check-p (board curr-check pos)
  (eql (board/square board (car pos) (cdr pos)) curr-check))
(defun square-empty-p (board curr-check pos)
  (eql (board/square board (car pos) (cdr pos)) :empty))
(defun distance (src-pos tgt-pos)
  (cons (- (car tgt-pos) (car src-pos))
        (- (cdr tgt-pos) (cdr src-pos))))
(defun hor-distance (board curr-check src-pos tgt-pos)
  (abs (car (distance src-pos tgt-pos))))
(defun ver-forward-distance (board curr-check src-pos tgt-pos)
  (alet (cdr (distance src-pos tgt-pos))
    (ecase (board/check-direction 
            (board/square board (car src-pos) (cdr src-pos)))
      (:up it)
      (:down (- it)))))
(defun ver-distance (board curr-check src-pos tgt-pos)
  (abs (cdr (distance src-pos tgt-pos))))
(defun half-distance (src-pos tgt-pos)
  (alet (distance src-pos tgt-pos)
    (cons (/ (car it) 2) (/ (cdr it) 2))))
(defun shifted-pos (src-pos vec)
  (cons (+ (car src-pos) (car vec)) 
        (+ (cdr src-pos) (cdr vec))))
(defun half-way-square-has-opposite-check-p (board curr-check src-pos tgt-pos)
  (alet (shifted-pos src-pos (half-distance src-pos tgt-pos))
    (eql (board/square-or-nil board (car it) (cdr it))
         (board/opposite-check curr-check))))
(defun move-check (board curr-check src-pos tgt-pos)
  (board/move-check board 
                    (car src-pos) (cdr src-pos) 
                    (car tgt-pos) (cdr tgt-pos)))
(defun kill-half-way-check (board curr-check src-pos tgt-pos)
  (alet (shifted-pos src-pos (half-distance src-pos tgt-pos))
    (board/kill-check board (car it) (cdr it))))
;; TODO: seems like it's easire just define moves hierarcy
;;
;;            move
;;           /    \
;;   basic-move  attack-move
;;
;; and so on...   
(defclass move ()
  ((predicate :initarg :predicate :reader move/predicate)
   (actor :initarg :actor :reader move/actor)))
(defparameter *moves* nil)
(defun move/validp (move board curr-check src-pos tgt-pos)
  (funcall (move/predicate move) board curr-check src-pos tgt-pos))
(defun move/apply (move board curr-check src-pos tgt-pos)
  (funcall (move/actor move) board curr-check src-pos tgt-pos))
(defun move/remove (name)
  (remf *moves* name))
(eval-when (:compile-toplevel :load-toplevel)
  (defun move/parse-pred-func-def (def)
    (values (first def) (cdr (butlast def)) (lastcar def)))
  (defun move/gen-pred-func-call (def)
    (multiple-value-bind (name args-rest result) (move/parse-pred-func-def def)
      `(eql ,(append (list name) 
                     '(board curr-check) 
                     args-rest)
            ,result)))
  (defun move/parse-act-func-def (def)
    (values (first def) (cdr def)))
  (defun move/gen-act-func-call (def)
    (multiple-value-bind (name args-rest) (move/parse-act-func-def def)
      (append (list name) '(board curr-check) args-rest))))
(defmacro defmove (name type (&rest patterns) (&rest actions))
  `(setf (getf *moves* ',name)  
         (make-instance 
          'move 
          :predicate (lambda (board curr-check source target)
                       (and ,@(loop for p in patterns
                                 collecting (move/gen-pred-func-call p))))
          :actor (lambda (board curr-check source target)
                   ,@(loop for a in actions
                        collecting (move/gen-act-func-call a))))))
(defmove basic :simple
    ((square-has-same-check-p source t) ;; can be removed ?
     (square-empty-p target t)     ;; 
     (hor-distance source target 1)
     (ver-forward-distance source target 1))
    ((move-check source target)))
(defmove attack :recursive
    ((square-has-same-check-p source t) ;; can be removed ?
     (square-empty-p target t)         ;; 
     (hor-distance source target 2)
     (ver-distance source target 2)
     (half-way-square-has-opposite-check-p source target t))
    ((kill-half-way-check source target)
     (move-check source target)))

(defparameter *window-width* 400)
(defparameter *window-height* 400)
(defparameter *square-color* (list :white (sdl:color :r #xE8 :g #xD0 :b #xAA)
                                   :black (sdl:color :r #xA6 :g #x7D :b #x5D)))
(defparameter *check-color* (list :white-check (sdl:color :r #xF6 :g #xC6 :b #x48)
                                  :black-check (sdl:color :r #x7A :g #x50 :b #x44)))
(defparameter *check-pin-color* (list :white-check (sdl:color :r #xFF :g #xD6 :b #x58)
                                      :black-check (sdl:color :r #x8A :g #x60 :b #x54)))
(defparameter *selected-check-x* 3)
(defparameter *selected-check-y* 3)
(defparameter *board* (make-board))
(defun window/calc-square-width (board)
  (/ *window-width* (board/width board)))
(defun window/calc-square-height (board)
  (/ *window-height* (board/height board)))
(defun window/draw-check (x y w h square)
  (sdl:draw-filled-circle-* (+ (* x w) (/ w 2)) (+ (* y h) (/ h 2))
                            (round (/ (/ (+ w h) 2) 3))
                            :color (getf *check-color* square))
  (sdl:draw-filled-circle-* (+ (* x w) (/ w 2)) (+ (* y h) (/ h 2))
                            (round (/ (/ (+ w h) 2) 6))
                            :color (getf *check-pin-color* square)))
(defun window/calc-inv-y (board y)
  (- (board/height board) y 1))
(defun window/draw-selected-square (board square-w square-h)
  (when (and *selected-check-x* *selected-check-y*)
    (sdl:draw-filled-circle-* (+ (* *selected-check-x* square-w) 
                                 (/ square-w 2)) 
                              (+ (* (window/calc-inv-y board *selected-check-y*) square-h) 
                                 (/ square-h 2))
                              (round (/ (/ (+ square-w square-h) 2) 2.5))
                              :color sdl:*blue*)))
(defun window/draw-move-variants (board square-w square-h)
  (when (and *selected-check-x* *selected-check-y*)
    (doboard (x y square board)
      (doplist (key move *moves*)
        (when (or nil (move/validp move 
                                   board 
                                   (board/square board *selected-check-x* *selected-check-y*)
                                   (cons *selected-check-x* *selected-check-y*) 
                                   (cons x y)))
          (sdl:draw-box-* (* x square-w)
                          (* (window/calc-inv-y board y) square-h)
                          square-w 
                          square-h
                          :color (sdl:color :r 60 :g 60 :b 60)
                          :alpha 125))))))
(defun window/draw-background (board square-w square-h)
  (doboard (x y square board)
      (let* ((inv-y (window/calc-inv-y board y))
             (window-x (* x square-w))
             (window-y (* inv-y square-h)))
        (sdl:draw-box-* window-x  window-y square-w square-h
                        :color (getf *square-color* (board/color x y))))))
(defun window/draw-checks (board square-w square-h)
  (doboard (x y square board)
    (alet (window/calc-inv-y board y)
      (when (not (eql square :empty))
        (window/draw-check x it square-w square-h square)))))
(defun window/draw-board (board)
  (let ((square-w  (window/calc-square-width board))
        (square-h (window/calc-square-height board)))
    (window/draw-background board square-w square-h)
    (window/draw-selected-square board square-w square-h)
    (window/draw-move-variants board square-w square-h)
    (window/draw-checks board square-w square-h)))
(defun window/draw-game (board)
  (window/draw-board board))
(defun window/handle-input (board key)
  (case key
    (:sdl-key-left (setf *selected-check-x* (max 0 (1- *selected-check-x*))))
    (:sdl-key-right (setf *selected-check-x* (min (1- (board/width board)) 
                                                  (1+ *selected-check-x*))))
    (:sdl-key-q (sdl:push-quit-event))))

;;; Entry point
(defun main ()
  (sdl:with-init ()
    (sdl:window *window-width* *window-height* :bpp 32)
    (sdl:with-events (:poll)
      (:quit-event () t)
      (:video-expose-event () (sdl:update-display))
      (:key-down-event (:key key) (window/handle-input *board* key))
      (:idle ()
             (restart-case
                 (sdl:with-surface (back-buffer (sdl:create-surface *window-width* 
                                                                    *window-height*
                                                                    :pixel-alpha 120))
                   (handle-slime-requests)
                   (sdl:clear-display sdl:*black*)
                   (window/draw-game *board*)
                   (sdl:blit-surface back-buffer sdl:*default-display*)
                   (sdl:update-display))
               (continue () :report "Continue interaction"))))))
